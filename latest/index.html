<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>beicon - reactive streams for Clojure(Script)</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic|Liberation+Mono:400|Roboto+Slab:400,700"/>
<link rel="stylesheet" href="https://www.niwi.nz/_assets/asciidoctor-styles/simple-red-titles/stylesheet.css"/>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>beicon - reactive streams for Clojure(Script)</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction">Introduction</a>
<ul class="sectlevel2">
<li><a href="#project-maturity">Project Maturity</a></li>
<li><a href="#install">Install</a></li>
</ul>
</li>
<li><a href="#creating-streams">Creating Streams</a>
<ul class="sectlevel2">
<li><a href="#from-a-collection">From a collection</a></li>
<li><a href="#from-range">From range</a></li>
<li><a href="#from-atom">From Atom</a></li>
<li><a href="#from-value">From Value</a></li>
<li><a href="#from-multiple-values">From multiple values</a></li>
<li><a href="#empty">Empty</a></li>
<li><a href="#with-timeout">With timeout</a></li>
<li><a href="#from-factory">From factory</a></li>
</ul>
</li>
<li><a href="#consuming-streams">Consuming streams</a>
<ul class="sectlevel2">
<li><a href="#the-stream-states">The stream states</a></li>
<li><a href="#general-purpose">General purpose</a></li>
<li><a href="#consume-values">Consume values</a></li>
<li><a href="#consume-successful-termination">Consume successful termination</a></li>
<li><a href="#consume-error-termination">Consume error termination</a></li>
<li><a href="#backpressure-aware-consumption">Backpressure-aware consumption</a></li>
</ul>
</li>
<li><a href="#transformations">Transformations</a>
<ul class="sectlevel2">
<li><a href="#filter">Filter</a></li>
<li><a href="#map">Map</a></li>
<li><a href="#flat-map">Flat Map</a></li>
<li><a href="#skip">Skip</a></li>
<li><a href="#take">Take</a></li>
<li><a href="#slice">Slice</a></li>
<li><a href="#reduce">Reduce</a></li>
<li><a href="#scan">Scan</a></li>
<li><a href="#buffer">Buffer</a></li>
</ul>
</li>
<li><a href="#combinators">Combinators</a>
<ul class="sectlevel2">
<li><a href="#choice">Choice</a></li>
<li><a href="#zip">Zip</a></li>
<li><a href="#concat">Concat</a></li>
<li><a href="#merge">Merge</a></li>
</ul>
</li>
<li><a href="#subject">Subject</a>
<ul class="sectlevel2">
<li><a href="#creating-a-subject">Creating a subject.</a></li>
<li><a href="#ending-a-subject">Ending a subject</a></li>
</ul>
</li>
<li><a href="#developers-guide">Developers Guide</a>
<ul class="sectlevel2">
<li><a href="#philosophy">Philosophy</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#source-code">Source Code</a></li>
<li><a href="#run-tests">Run tests</a></li>
<li><a href="#license">License</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="introduction"><a class="link" href="#introduction">Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>beicon</em> is a small and concise library that provides reactive streams API for
Clojure and ClojureScript.</p>
</div>
<div class="sect2">
<h3 id="project-maturity"><a class="link" href="#project-maturity">Project Maturity</a></h3>
<div class="paragraph">
<p>Since <em>beicon</em> is a young project there can be some API breakage.</p>
</div>
</div>
<div class="sect2">
<h3 id="install"><a class="link" href="#install">Install</a></h3>
<div class="paragraph">
<p>The simplest way to use <em>beicon</em> in a Clojure project, is by including it in the
dependency vector on your <strong><em>project.clj</em></strong> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">[</span><span class="tok-nv">funcool/beicon</span> <span class="tok-s">&quot;5.1.0&quot;</span><span class="tok-p">]</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-streams"><a class="link" href="#creating-streams">Creating Streams</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section will give you the available methods for create observable streams.</p>
</div>
<div class="sect2">
<h3 id="from-a-collection"><a class="link" href="#from-a-collection">From a collection</a></h3>
<div class="paragraph">
<p>The most basic way to create a stream is to just take a collection
and convert it into an observable sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">beicon.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">rx</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; ==&gt; v: 1</span>
<span class="tok-c1">;; ==&gt; v: 2</span>
<span class="tok-c1">;; ==&gt; v: 3</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="from-range"><a class="link" href="#from-range">From range</a></h3>
<div class="paragraph">
<p>An other way to create an observable stream is using the <code>range</code> constructor,
which is pretty analogous to the Clojures one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/range</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; ==&gt; v: 0</span>
<span class="tok-c1">;; ==&gt; v: 1</span>
<span class="tok-c1">;; ==&gt; v: 2</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="from-atom"><a class="link" href="#from-atom">From Atom</a></h3>
<div class="paragraph">
<p>Atoms in Clojure are watchable, so you can listen for their
changes. This method converts that changes into an infinite observable
sequence of atom changes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">atom</span> <span class="tok-mi">1</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-atom</span> <span class="tok-nv">a</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-nf">swap!</span> <span class="tok-nv">a</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
<span class="tok-c1">;; ==&gt; v: 2</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="from-value"><a class="link" href="#from-value">From Value</a></h3>
<div class="paragraph">
<p>It creates an observable sequence of one unique value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/just</span> <span class="tok-mi">10</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; ==&gt; v: 10</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>just</code> or <code>once</code> are simple aliases to <code>of</code> function.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="from-multiple-values"><a class="link" href="#from-multiple-values">From multiple values</a></h3>
<div class="paragraph">
<p>There is a way to create an observable sequence from
multiple values, using the <code>of</code> constructor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/of</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; ==&gt; v: 1</span>
<span class="tok-c1">;; ==&gt; v: 2</span>
<span class="tok-c1">;; ==&gt; v: 3</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="empty"><a class="link" href="#empty">Empty</a></h3>
<div class="paragraph">
<p>Some times you also want just a terminated stream:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/empty</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This stream does not yield any value and just terminates.</p>
</div>
</div>
<div class="sect2">
<h3 id="with-timeout"><a class="link" href="#with-timeout">With timeout</a></h3>
<div class="paragraph">
<p>This allows to create an observable sequence of one unique value, that
will be emitted after a specified amount of time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/timeout</span> <span class="tok-mi">1000</span> <span class="tok-mi">10</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; After 1 sec...</span>
<span class="tok-c1">;; ==&gt; v: 10</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="from-factory"><a class="link" href="#from-factory">From factory</a></h3>
<div class="paragraph">
<p>This is the most advanced and flexible way to create an observable
sequence. It allows to have control about termination and errors, and
is intended to be used for building other kinds of constructors.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span>
  <span class="tok-p">(</span><span class="tok-nf">rx/create</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">sink</span><span class="tok-p">]</span>
               <span class="tok-p">(</span><span class="tok-nf">sink</span> <span class="tok-mi">1</span><span class="tok-p">)</span>          <span class="tok-c1">;; next with `1` as value</span>
               <span class="tok-p">(</span><span class="tok-nf">sink</span> <span class="tok-p">(</span><span class="tok-nf">rx/end</span> <span class="tok-mi">2</span><span class="tok-p">))</span> <span class="tok-c1">;; next with `2` as value and end the stream</span>
               <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[]</span>
                 <span class="tok-c1">;; function called on unsubscription</span>
                 <span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; ==&gt; v: 1</span>
<span class="tok-c1">;; ==&gt; v: 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is implemented using protocols to make it flexible and easily
extensible by the user. This is how the default implementation
behaves:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Exceptions or exception instances trigger the error termination of stream.</p>
</li>
<li>
<p><code>(rx/end value)</code> sends the unwrapped value to the stream, then terminates stream.</p>
</li>
<li>
<p><code>rx/end</code> as value triggers the stream termination.</p>
</li>
<li>
<p><code>nil</code> triggers stream validation.</p>
</li>
<li>
<p>any other values are valid values for sending to the stream.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>On the JVM, there are other factory methods, that allow creation of
backpressure-aware observables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span>
  <span class="tok-p">(</span><span class="tok-nf">rx/generate</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">state</span> <span class="tok-nv">sink</span><span class="tok-p">]</span>
                 <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">nextval</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">state</span><span class="tok-p">)]</span>
                   <span class="tok-p">(</span><span class="tok-nf">sink</span> <span class="tok-nv">nextval</span><span class="tok-p">)</span>
                   <span class="tok-nv">nextval</span><span class="tok-p">))</span>
               <span class="tok-p">(</span><span class="tok-nb">constantly </span><span class="tok-mi">0</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The difference to the <code>create</code> function, the <code>generate</code> executes the
factory function multiple times and you need to call sink <strong>once</strong> for
each execution. Additionally, you can maintain state between
executions retuning the desired value and that value will passed as
first argument on the next execution. You can optionally provide an
initial state using the second argument <code>setup</code> and a third <code>dispose</code>
callback.</p>
</div>
<div class="paragraph">
<p>Many simple observables can be converted to be backpressure-aware
using the <code>to-flowable</code> function. Be aware, that the default strategy
<code>:buffer</code> (see below) is used by default to handle backpressure (over
production).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
     <span class="tok-p">(</span><span class="tok-nf">rx/to-flowable</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Optionally, you can specify the strategy to use for handling
backpressure by the first argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
     <span class="tok-p">(</span><span class="tok-nf">rx/to-flowable</span> <span class="tok-ss">:error</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a list of available strategies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:buffer</code> - Buffers all values until the downstream consumes it.</p>
</li>
<li>
<p><code>:error</code> - Signals a <code>MissingBackpressureException</code> in case the downstream can&#8217;t keep up.</p>
</li>
<li>
<p><code>:drop</code> - Drops the most recent value, if the downstream can&#8217;t keep up.</p>
</li>
<li>
<p><code>:latest</code> - Keeps only the latest value, overwriting any previous value, if the downstream can&#8217;t keep up.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="consuming-streams"><a class="link" href="#consuming-streams">Consuming streams</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="the-stream-states"><a class="link" href="#the-stream-states">The stream states</a></h3>
<div class="paragraph">
<p>The observable sequence can be in three different kind of states:
<strong>alive</strong>, <strong>"errored"</strong> or <strong>ended</strong>. If an error is emitted the stream can
be considered ended with an error.  So <strong>error</strong> or <strong>end</strong> states are
considered termination states.</p>
</div>
<div class="paragraph">
<p>And for convenience you can subscribe to any of that states of an
observable sequence.</p>
</div>
</div>
<div class="sect2">
<h3 id="general-purpose"><a class="link" href="#general-purpose">General purpose</a></h3>
<div class="paragraph">
<p>A general purpose subscription is one that allows you to create one
subscription, that watches all the different possible states of an
observable sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sub</span> <span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
                       <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
                       <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
                       <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end:&quot;</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The return value of the <code>subscribe</code> function is a subscription object,
that identifies the current subscription. It can be cancelled by
executing <code>(rx/cancel! sub)</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="consume-values"><a class="link" href="#consume-values">Consume values</a></h3>
<div class="paragraph">
<p>But in most circumstances you only want to consume values regardless
of any error or termination. For this purposes there is the <code>on-value</code>
function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sub</span> <span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">sub</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;val:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Like with the <code>subscribe</code> function, the <code>on-value</code> function also
returns a callable, that, when called, will dispose the created
subscription.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
take care, that calling any one of those helper functions
creates a separated subscription and it can behave unexpectedly, if
you are not aware whether you are using <a href="#hot or cold observables">hot-vs-cold-observales</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="consume-successful-termination"><a class="link" href="#consume-successful-termination">Consume successful termination</a></h3>
<div class="paragraph">
<p>With the <code>on-end</code> function you can watch the successful termination of
an observable sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sub</span> <span class="tok-p">(</span><span class="tok-nf">rx/on-end</span> <span class="tok-nv">sub</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;end!&quot;</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="consume-error-termination"><a class="link" href="#consume-error-termination">Consume error termination</a></h3>
<div class="paragraph">
<p>With the <code>on-error</code> function you can watch the error termination of an
observable sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sub</span> <span class="tok-p">(</span><span class="tok-nf">rx/on-end</span> <span class="tok-nv">sub</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="backpressure-aware-consumption"><a class="link" href="#backpressure-aware-consumption">Backpressure-aware consumption</a></h3>
<div class="paragraph">
<p>The streams created using the <code>generate</code> function, are
backpressure-aware streams and can be consumed in an
backpressure-aware way. For this you need to pass an object, that
implements the <code>ISubscriber</code> protocol. Lets see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span>
  <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
       <span class="tok-p">(</span><span class="tok-nf">rx/to-flowable</span> <span class="tok-ss">:buffer</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe-with</span> <span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">reify</span> <span class="tok-nv">rx/ISubscriber</span>
                            <span class="tok-p">(</span><span class="tok-nf">-on-init</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">s</span><span class="tok-p">]</span>
                              <span class="tok-p">(</span><span class="tok-nf">s/request!</span> <span class="tok-nv">s</span> <span class="tok-mi">1</span><span class="tok-p">))</span>

                            <span class="tok-p">(</span><span class="tok-nf">-on-next</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">s</span> <span class="tok-nv">v</span><span class="tok-p">]</span>
                              <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-next:&quot;</span> <span class="tok-nv">v</span><span class="tok-p">)</span>
                              <span class="tok-p">(</span><span class="tok-nf">s/request!</span> <span class="tok-nv">s</span> <span class="tok-mi">1</span><span class="tok-p">))</span>

                            <span class="tok-p">(</span><span class="tok-nf">-on-error</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">e</span><span class="tok-p">]</span>
                              <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error&quot;</span><span class="tok-p">))</span>

                            <span class="tok-p">(</span><span class="tok-nf">-on-end</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
                              <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))))</span>
<span class="tok-c1">;; =&gt; on-next: 1</span>
<span class="tok-c1">;; =&gt; on-next: 2</span>
<span class="tok-c1">;; =&gt; on-next: 3</span>
<span class="tok-c1">;; =&gt; on-end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the same way as the <code>subscribe</code> function, the <code>subscribe-with</code>
returns a cancellable subscription object.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transformations"><a class="link" href="#transformations">Transformations</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="filter"><a class="link" href="#filter">Filter</a></h3>
<div class="paragraph">
<p>The main advantage of using reactive streams is that you may treat them like
normal sequences, and in this case filter them with a predicate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/filter</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">&gt; </span><span class="tok-nv">%</span> <span class="tok-mi">3</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 4</span>
<span class="tok-c1">;; ==&gt; on-value: 5</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="map"><a class="link" href="#map">Map</a></h3>
<div class="paragraph">
<p>Also, you can apply a function over each value in the stream:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/map</span> <span class="tok-nv">inc</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="flat-map"><a class="link" href="#flat-map">Flat Map</a></h3>
<div class="paragraph">
<p>Converts an observable sequence, that can contain other observable sequences, into a
new observable sequence, that emits just plain values.</p>
</div>
<div class="paragraph">
<p>The result is similar to concatenating all the underlying sequences.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/map</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nf">sfrom-coll</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-nv">%</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">%</span> <span class="tok-mi">2</span><span class="tok-p">))))</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/flat-map</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="skip"><a class="link" href="#skip">Skip</a></h3>
<div class="paragraph">
<p>Also, sometimes you just want to skip values from stream by different criteria.</p>
</div>
<div class="paragraph">
<p>You can skip the first N values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-mi">6</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/skip</span> <span class="tok-mi">4</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 5</span>
<span class="tok-c1">;; ==&gt; on-value: 6</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Skip while some predicate evaluates to <code>true</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/skip-while</span> <span class="tok-nv">odd?</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Or skip until another observable yields a value with <code>skip-until</code> (no
example at this moment).</p>
</div>
</div>
<div class="sect2">
<h3 id="take"><a class="link" href="#take">Take</a></h3>
<div class="paragraph">
<p>You can also limit the observable sequence to an specified number of
elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/take</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Or a predicate evaluates to <code>true</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/take-while</span> <span class="tok-nv">odd?</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="slice"><a class="link" href="#slice">Slice</a></h3>
<div class="paragraph">
<p>This is a combination of <code>skip</code> and <code>take</code>, and returns an observable
sequence, that represents the portion between start and end of the
source observable sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/slice</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reduce"><a class="link" href="#reduce">Reduce</a></h3>
<div class="paragraph">
<p>Allows combining all results of an observable sequence using a
combining function (also called <strong>reducing</strong> function):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/reduce</span> <span class="tok-nb">+ </span><span class="tok-mi">0</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 10</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scan"><a class="link" href="#scan">Scan</a></h3>
<div class="paragraph">
<p>Like <code>reduce</code> (see above), but returns a stream of each intermediate
result instead (similar to <code>reductions</code> in Clojure):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/scan</span> <span class="tok-nb">+ </span><span class="tok-mi">0</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-value: 6</span>
<span class="tok-c1">;; ==&gt; on-value: 10</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="buffer"><a class="link" href="#buffer">Buffer</a></h3>
<div class="paragraph">
<p>This transformer function allows to accumulate N values in a buffer
and then emits them as one value (similar to <code>partition</code> in Clojure)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/buffer</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: [1 2]</span>
<span class="tok-c1">;; ==&gt; on-value: [3 4]</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="combinators"><a class="link" href="#combinators">Combinators</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="choice"><a class="link" href="#choice">Choice</a></h3>
<div class="paragraph">
<p>Performs an arbitrary choice between two or more observable sequences
and returns the first value available from any provided observables.</p>
</div>
<div class="paragraph">
<p>This kind of combinator works very well with operations that can
timeout:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/choice</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/timeout</span> <span class="tok-mi">1000</span> <span class="tok-ss">:timeout</span><span class="tok-p">)</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/timeout</span> <span class="tok-mi">900</span> <span class="tok-ss">:value</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: :value</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zip"><a class="link" href="#zip">Zip</a></h3>
<div class="paragraph">
<p>This combinator combines two observable sequences in one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/zip</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: [1 2]</span>
<span class="tok-c1">;; ==&gt; on-value: [2 3]</span>
<span class="tok-c1">;; ==&gt; on-value: [3 4]</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concat"><a class="link" href="#concat">Concat</a></h3>
<div class="paragraph">
<p>This combinator concatenates two or more observable sequences <strong>in
order</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/concat</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-value: 4</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="merge"><a class="link" href="#merge">Merge</a></h3>
<div class="paragraph">
<p>This combinator merges two or more observable sequences <strong>at random</strong> (see
<code>concat</code> for ordered).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/merge</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 4</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="subject"><a class="link" href="#subject">Subject</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is an abstraction that combines observable sequence with the
observer. So you can push values into it and transform and subscribe
to it like any other sequence.</p>
</div>
<div class="sect2">
<h3 id="creating-a-subject"><a class="link" href="#creating-a-subject">Creating a subject.</a></h3>
<div class="paragraph">
<p>You can create a subject instance using the <code>subject</code> constructor
function.</p>
</div>
<div class="paragraph">
<p>This is an example of using <code>subject</code> for two things: push values and
subscribe to it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">subject</span> <span class="tok-p">(</span><span class="tok-nf">rx/subject</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-nv">subject</span>
                <span class="tok-p">(</span><span class="tok-nf">rx/skip</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
                <span class="tok-p">(</span><span class="tok-nf">rx/map</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
                <span class="tok-p">(</span><span class="tok-nf">rx/take</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/push!</span> <span class="tok-nv">subject</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">rx/push!</span> <span class="tok-nv">subject</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">rx/push!</span> <span class="tok-nv">subject</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">rx/push!</span> <span class="tok-nv">subject</span> <span class="tok-mi">2</span><span class="tok-p">)</span>

<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ending-a-subject"><a class="link" href="#ending-a-subject">Ending a subject</a></h3>
<div class="paragraph">
<p>You can end a subject at any moment just by executing the <code>end!</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">subject</span> <span class="tok-p">(</span><span class="tok-nf">rx/subject</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">subject</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/end!</span> <span class="tok-nv">subject</span><span class="tok-p">)</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="developers-guide"><a class="link" href="#developers-guide">Developers Guide</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="philosophy"><a class="link" href="#philosophy">Philosophy</a></h3>
<div class="paragraph">
<p>Five most important rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Beautiful is better than ugly.</p>
</li>
<li>
<p>Explicit is better than implicit.</p>
</li>
<li>
<p>Simple is better than complex.</p>
</li>
<li>
<p>Complex is better than complicated.</p>
</li>
<li>
<p>Readability counts.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All contributions to <em>beicon</em> should keep these important rules in mind.</p>
</div>
</div>
<div class="sect2">
<h3 id="contributing"><a class="link" href="#contributing">Contributing</a></h3>
<div class="paragraph">
<p>Unlike Clojure and other Clojure contributed libraries <em>beicon</em> does
not have many restrictions for contributions. Just open an issue or
pull request.</p>
</div>
</div>
<div class="sect2">
<h3 id="source-code"><a class="link" href="#source-code">Source Code</a></h3>
<div class="paragraph">
<p><em>beicon</em> is open source and can be found on
<a href="https://github.com/funcool/beicon">github</a>.</p>
</div>
<div class="paragraph">
<p>You can clone the public repository with this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text"><span></span>git clone https://github.com/funcool/beicon</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="run-tests"><a class="link" href="#run-tests">Run tests</a></h3>
<div class="paragraph">
<p>For running tests just execute this:</p>
</div>
<div class="listingblock">
<div class="title">ClojureScript</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>./scrpts/build
node ./out/tests.js</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Clojure</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>lein <span class="tok-nb">test</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="license"><a class="link" href="#license">License</a></h3>
<div class="paragraph">
<p><em>beicon</em> is licensed under BSD (2-Clause) license:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Copyright (c) 2015-2019 Andrey Antukh &lt;niwi@niwi.nz&gt;

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-08-20 09:15:27 +0200
</div>
</div>
<style>
pre.pygments .hll { background-color: #ffffcc }
pre.pygments  { background: #f0f0f0; }
pre.pygments .tok-c { color: #60a0b0; font-style: italic } /* Comment */
pre.pygments .tok-err { border: 1px solid #FF0000 } /* Error */
pre.pygments .tok-k { color: #007020; font-weight: bold } /* Keyword */
pre.pygments .tok-o { color: #666666 } /* Operator */
pre.pygments .tok-ch { color: #60a0b0; font-style: italic } /* Comment.Hashbang */
pre.pygments .tok-cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
pre.pygments .tok-cp { color: #007020 } /* Comment.Preproc */
pre.pygments .tok-cpf { color: #60a0b0; font-style: italic } /* Comment.PreprocFile */
pre.pygments .tok-c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
pre.pygments .tok-cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
pre.pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
pre.pygments .tok-ge { font-style: italic } /* Generic.Emph */
pre.pygments .tok-gr { color: #FF0000 } /* Generic.Error */
pre.pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
pre.pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
pre.pygments .tok-go { color: #888888 } /* Generic.Output */
pre.pygments .tok-gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
pre.pygments .tok-gs { font-weight: bold } /* Generic.Strong */
pre.pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
pre.pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
pre.pygments .tok-kc { color: #007020; font-weight: bold } /* Keyword.Constant */
pre.pygments .tok-kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
pre.pygments .tok-kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
pre.pygments .tok-kp { color: #007020 } /* Keyword.Pseudo */
pre.pygments .tok-kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
pre.pygments .tok-kt { color: #902000 } /* Keyword.Type */
pre.pygments .tok-m { color: #40a070 } /* Literal.Number */
pre.pygments .tok-s { color: #4070a0 } /* Literal.String */
pre.pygments .tok-na { color: #4070a0 } /* Name.Attribute */
pre.pygments .tok-nb { color: #007020 } /* Name.Builtin */
pre.pygments .tok-nc { color: #0e84b5; font-weight: bold } /* Name.Class */
pre.pygments .tok-no { color: #60add5 } /* Name.Constant */
pre.pygments .tok-nd { color: #555555; font-weight: bold } /* Name.Decorator */
pre.pygments .tok-ni { color: #d55537; font-weight: bold } /* Name.Entity */
pre.pygments .tok-ne { color: #007020 } /* Name.Exception */
pre.pygments .tok-nf { color: #06287e } /* Name.Function */
pre.pygments .tok-nl { color: #002070; font-weight: bold } /* Name.Label */
pre.pygments .tok-nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
pre.pygments .tok-nt { color: #062873; font-weight: bold } /* Name.Tag */
pre.pygments .tok-nv { color: #bb60d5 } /* Name.Variable */
pre.pygments .tok-ow { color: #007020; font-weight: bold } /* Operator.Word */
pre.pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
pre.pygments .tok-mb { color: #40a070 } /* Literal.Number.Bin */
pre.pygments .tok-mf { color: #40a070 } /* Literal.Number.Float */
pre.pygments .tok-mh { color: #40a070 } /* Literal.Number.Hex */
pre.pygments .tok-mi { color: #40a070 } /* Literal.Number.Integer */
pre.pygments .tok-mo { color: #40a070 } /* Literal.Number.Oct */
pre.pygments .tok-sa { color: #4070a0 } /* Literal.String.Affix */
pre.pygments .tok-sb { color: #4070a0 } /* Literal.String.Backtick */
pre.pygments .tok-sc { color: #4070a0 } /* Literal.String.Char */
pre.pygments .tok-dl { color: #4070a0 } /* Literal.String.Delimiter */
pre.pygments .tok-sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
pre.pygments .tok-s2 { color: #4070a0 } /* Literal.String.Double */
pre.pygments .tok-se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
pre.pygments .tok-sh { color: #4070a0 } /* Literal.String.Heredoc */
pre.pygments .tok-si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
pre.pygments .tok-sx { color: #c65d09 } /* Literal.String.Other */
pre.pygments .tok-sr { color: #235388 } /* Literal.String.Regex */
pre.pygments .tok-s1 { color: #4070a0 } /* Literal.String.Single */
pre.pygments .tok-ss { color: #517918 } /* Literal.String.Symbol */
pre.pygments .tok-bp { color: #007020 } /* Name.Builtin.Pseudo */
pre.pygments .tok-fm { color: #06287e } /* Name.Function.Magic */
pre.pygments .tok-vc { color: #bb60d5 } /* Name.Variable.Class */
pre.pygments .tok-vg { color: #bb60d5 } /* Name.Variable.Global */
pre.pygments .tok-vi { color: #bb60d5 } /* Name.Variable.Instance */
pre.pygments .tok-vm { color: #bb60d5 } /* Name.Variable.Magic */
pre.pygments .tok-il { color: #40a070 } /* Literal.Number.Integer.Long */
</style>
</body>
</html>