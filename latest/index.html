<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>beicon - reactive streams for Clojure(Script)</title>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments, .listingblock .pygments code { background: #f0f0f0; }
.listingblock .pygments .tok-c { color: #60a0b0; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #007020; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-ch { color: #60a0b0; font-style: italic } /* Comment.Hashbang */
.listingblock .pygments .tok-cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #007020 } /* Comment.Preproc */
.listingblock .pygments .tok-cpf { color: #60a0b0; font-style: italic } /* Comment.PreprocFile */
.listingblock .pygments .tok-c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #007020; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #007020 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #902000 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #40a070 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #4070a0 } /* Literal.String */
.listingblock .pygments .tok-na { color: #4070a0 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #007020 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0e84b5; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #60add5 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #555555; font-weight: bold } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #d55537; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #007020 } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #06287e } /* Name.Function */
.listingblock .pygments .tok-nl { color: #002070; font-weight: bold } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #062873; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #bb60d5 } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #007020; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #40a070 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #40a070 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #40a070 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #40a070 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #40a070 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sa { color: #4070a0 } /* Literal.String.Affix */
.listingblock .pygments .tok-sb { color: #4070a0 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #4070a0 } /* Literal.String.Char */
.listingblock .pygments .tok-dl { color: #4070a0 } /* Literal.String.Delimiter */
.listingblock .pygments .tok-sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #4070a0 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #4070a0 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #c65d09 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #235388 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #4070a0 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #517918 } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #007020 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-fm { color: #06287e } /* Name.Function.Magic */
.listingblock .pygments .tok-vc { color: #bb60d5 } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #bb60d5 } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #bb60d5 } /* Name.Variable.Instance */
.listingblock .pygments .tok-vm { color: #bb60d5 } /* Name.Variable.Magic */
.listingblock .pygments .tok-il { color: #40a070 } /* Literal.Number.Integer.Long */
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic|Liberation+Mono:400|Roboto+Slab:400,700"/>
<link rel="stylesheet" href="https://www.niwi.nz/_assets/asciidoctor-styles/simple-red-titles/stylesheet.css"/>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>beicon - reactive streams for Clojure(Script)</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction">Introduction</a>
<ul class="sectlevel2">
<li><a href="#project-maturity">Project Maturity</a></li>
<li><a href="#install">Install</a></li>
</ul>
</li>
<li><a href="#creating-streams">Creating Streams</a>
<ul class="sectlevel2">
<li><a href="#from-a-collection">From a collection</a></li>
<li><a href="#from-range">From range</a></li>
<li><a href="#from-atom">From Atom</a></li>
<li><a href="#from-value">From Value</a></li>
<li><a href="#from-multiple-values">From multiple values</a></li>
<li><a href="#empty">Empty</a></li>
<li><a href="#with-timeout">With timeout</a></li>
<li><a href="#from-factory">From factory</a></li>
</ul>
</li>
<li><a href="#consuming-streams">Consuming streams</a>
<ul class="sectlevel2">
<li><a href="#the-stream-states">The stream states</a></li>
<li><a href="#general-purpose">General purpose</a></li>
<li><a href="#consume-values">Consume values</a></li>
<li><a href="#consume-successful-termination">Consume successful termination</a></li>
<li><a href="#consume-error-termination">Consume error termination</a></li>
<li><a href="#backpressure-aware-consimption">Backpressure-aware consimption</a></li>
</ul>
</li>
<li><a href="#transformations">Transformations</a>
<ul class="sectlevel2">
<li><a href="#filter">Filter</a></li>
<li><a href="#map">Map</a></li>
<li><a href="#flat-map">Flat Map</a></li>
<li><a href="#skip">Skip</a></li>
<li><a href="#take">Take</a></li>
<li><a href="#slice">Slice</a></li>
<li><a href="#reduce">Reduce</a></li>
<li><a href="#scan">Scan</a></li>
<li><a href="#buffer">Buffer</a></li>
</ul>
</li>
<li><a href="#combinators">Combinators</a>
<ul class="sectlevel2">
<li><a href="#choice">Choice</a></li>
<li><a href="#zip">Zip</a></li>
<li><a href="#concat">Concat</a></li>
<li><a href="#merge">Merge</a></li>
</ul>
</li>
<li><a href="#subject">Subject</a>
<ul class="sectlevel2">
<li><a href="#creating-a-subject">Creating a subject.</a></li>
<li><a href="#ending-a-subject">Ending a subject</a></li>
</ul>
</li>
<li><a href="#developers-guide">Developers Guide</a>
<ul class="sectlevel2">
<li><a href="#philosophy">Philosophy</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#source-code">Source Code</a></li>
<li><a href="#run-tests">Run tests</a></li>
<li><a href="#license">License</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="introduction"><a class="link" href="#introduction">Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>beicon</em> is a small and concise library that provides reactive streams api for
clojure and clojurescript.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>This documentation does not covers all api, so if you miss
some function, contributions are very welcome. You can see the full
<a href="api/index.html#id">API documentation here</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="project-maturity"><a class="link" href="#project-maturity">Project Maturity</a></h3>
<div class="paragraph">
<p>Since <em>beicon</em> is a young project there can be some API breakage.</p>
</div>
</div>
<div class="sect2">
<h3 id="install"><a class="link" href="#install">Install</a></h3>
<div class="paragraph">
<p>The simplest way to use <em>beicon</em> in a clojure project, is by including it in the
dependency vector on your <strong><em>project.clj</em></strong> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">[</span><span class="tok-nv">funcool/beicon</span> <span class="tok-s">&quot;3.0.0&quot;</span><span class="tok-p">]</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-streams"><a class="link" href="#creating-streams">Creating Streams</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section will give you the available methods for create observable streams.</p>
</div>
<div class="sect2">
<h3 id="from-a-collection"><a class="link" href="#from-a-collection">From a collection</a></h3>
<div class="paragraph">
<p>The most basic way to create a streamm is just take a collection
and convert it in an observable sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">beicon.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">rx</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; ==&gt; v: 1</span>
<span class="tok-c1">;; ==&gt; v: 2</span>
<span class="tok-c1">;; ==&gt; v: 3</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="from-range"><a class="link" href="#from-range">From range</a></h3>
<div class="paragraph">
<p>An other way to create an observable stream is using the <code>range</code> constructor
that is pretty analogous to the clojure&#8217;s one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/range</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; ==&gt; v: 0</span>
<span class="tok-c1">;; ==&gt; v: 1</span>
<span class="tok-c1">;; ==&gt; v: 2</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="from-atom"><a class="link" href="#from-atom">From Atom</a></h3>
<div class="paragraph">
<p>Atoms in clojure are watchable, so you can listen its changes. This method convert
that changes in an infinite observable sequence of atom changes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">atom</span> <span class="tok-mi">1</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-atom</span> <span class="tok-nv">a</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-nf">swap!</span> <span class="tok-nv">a</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
<span class="tok-c1">;; ==&gt; v: 2</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="from-value"><a class="link" href="#from-value">From Value</a></h3>
<div class="paragraph">
<p>It creates an observable sequence of one unique value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/just</span> <span class="tok-mi">10</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; ==&gt; v: 10</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>just</code> or <code>once</code> are simple aliases to <code>of</code> function.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="from-multiple-values"><a class="link" href="#from-multiple-values">From multiple values</a></h3>
<div class="paragraph">
<p>It there is a way for create an observable seequence from
multiple values, using the <code>of</code> consturctor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/of</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; ==&gt; v: 1</span>
<span class="tok-c1">;; ==&gt; v: 2</span>
<span class="tok-c1">;; ==&gt; v: 3</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="empty"><a class="link" href="#empty">Empty</a></h3>
<div class="paragraph">
<p>Some times you also want just a terminated stream:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/empty</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This stream not yelds any value and just terminates.</p>
</div>
</div>
<div class="sect2">
<h3 id="with-timeout"><a class="link" href="#with-timeout">With timeout</a></h3>
<div class="paragraph">
<p>This allow create an observable seequence of one unique value that will be emited
after specified amount of time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/timeout</span> <span class="tok-mi">1000</span> <span class="tok-mi">10</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; After 1 sec...</span>
<span class="tok-c1">;; ==&gt; v: 10</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="from-factory"><a class="link" href="#from-factory">From factory</a></h3>
<div class="paragraph">
<p>This is the most advanced and flexible way to create an observable sequence. It
allows to have control about termination and errors and intended to be used
for build other kinds of constructors.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span>
  <span class="tok-p">(</span><span class="tok-nf">rx/create</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">sink</span><span class="tok-p">]</span>
               <span class="tok-p">(</span><span class="tok-nf">sink</span> <span class="tok-mi">1</span><span class="tok-p">)</span>          <span class="tok-c1">;; next with `1` as value</span>
               <span class="tok-p">(</span><span class="tok-nf">sink</span> <span class="tok-p">(</span><span class="tok-nf">rx/end</span> <span class="tok-mi">2</span><span class="tok-p">))</span> <span class="tok-c1">;; next with `2` as value and end the stream</span>
               <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[]</span>
                 <span class="tok-c1">;; function called on unsubscription</span>
                 <span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">stream</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;v:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; ==&gt; v: 1</span>
<span class="tok-c1">;; ==&gt; v: 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is implemented using protocols for make it flexible and easy extensible
by the user. This is how the default impl behaves:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Exceptions or exception instances triggers the error termination of stream.</p>
</li>
<li>
<p><code>(rx/end value)</code> sends the unwrapped value to the stream, then terminate stream.</p>
</li>
<li>
<p><code>rx/end</code> as value triggers the stream termination.</p>
</li>
<li>
<p><code>nil</code> triggers stream validation.</p>
</li>
<li>
<p>any other value are valid values for send to the stream.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>On the JVM, there are other factory method that allow create backpressure-aware
observables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span>
  <span class="tok-p">(</span><span class="tok-nf">rx/generate</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">state</span> <span class="tok-nv">sink</span><span class="tok-p">]</span>
                 <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">nextval</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">state</span><span class="tok-p">)]</span>
                   <span class="tok-p">(</span><span class="tok-nf">sink</span> <span class="tok-nv">nextval</span><span class="tok-p">)</span>
                   <span class="tok-nv">nextval</span><span class="tok-p">))</span>
               <span class="tok-p">(</span><span class="tok-nb">constantly </span><span class="tok-mi">0</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The difference with the <code>create</code> function, the <code>generate</code> executes the
factory function multiple and you need to call sink <strong>once</strong> for each
execution. Additionally, you can maintain state between executions
retuning the desired value, that value will passed as first argument
on the next execution. You can provide an initial state using the
second argument and dispose callback as third argument.</p>
</div>
<div class="paragraph">
<p>Many simple observables can be converted to be backpressure-aware using
the <code>to-flowable</code> function. Take cara that there are no magic, the buffering
strategy is used by default for handle backpressure (over production).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
     <span class="tok-p">(</span><span class="tok-nf">rx/to-flowable</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Optionally, you can specify the strategy to use for handle backpressure
using the first argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
     <span class="tok-p">(</span><span class="tok-nf">rx/to-flowable</span> <span class="tok-ss">:error</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a list of available strategies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:buffer</code> - Buffers all values until the downstream consumes it.</p>
</li>
<li>
<p><code>:error</code> - Signals a <code>MissingBackpressureException</code> in case the downstream can&#8217;t keep up.</p>
</li>
<li>
<p><code>:drop</code> - Drops the most recent value if the downstream can&#8217;t keep up.</p>
</li>
<li>
<p><code>:latest</code> - Keeps only the latest value, overwriting any previous value if the downstream can&#8217;t keep up.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="consuming-streams"><a class="link" href="#consuming-streams">Consuming streams</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="the-stream-states"><a class="link" href="#the-stream-states">The stream states</a></h3>
<div class="paragraph">
<p>The observable sequence can be in 3 different kind of states: alive, errored or
ended. I an error is emited the stream can be considered ended with an error.
So error or end states can be considered termination states.</p>
</div>
<div class="paragraph">
<p>And is convenient you can subscribe to any of that states of an observable
sequence.</p>
</div>
</div>
<div class="sect2">
<h3 id="general-purpose"><a class="link" href="#general-purpose">General purpose</a></h3>
<div class="paragraph">
<p>A general purpose subscription is one that allows you create one subscription
that watches all the different possible states of an observable sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sub</span> <span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
                       <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
                       <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
                       <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end:&quot;</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The return value of <code>subscribe</code> function is a subscription object that identifies
the current subscription. It can be cancelled executing <code>(rx/cancel! sub)</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="consume-values"><a class="link" href="#consume-values">Consume values</a></h3>
<div class="paragraph">
<p>But in most circumstances you only want consume values regardless of any error
or termination. For this purposes is there the <code>on-value</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sub</span> <span class="tok-p">(</span><span class="tok-nf">rx/on-value</span> <span class="tok-nv">sub</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;val:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Like with <code>subscribe</code> function, <code>on-value</code> function also return a callable that
when is called will dispose the created subscription.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
take care that calling any one of that helper functions creates a
separated subscription and it can behave unexpectly if you do not aware if you
are using <a href="#hot or cold observables">hot-vs-cold-observales</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="consume-successful-termination"><a class="link" href="#consume-successful-termination">Consume successful termination</a></h3>
<div class="paragraph">
<p>With <code>on-end</code> function you can watch the successful termination of an observable
sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sub</span> <span class="tok-p">(</span><span class="tok-nf">rx/on-end</span> <span class="tok-nv">sub</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;end!&quot;</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="consume-error-termination"><a class="link" href="#consume-error-termination">Consume error termination</a></h3>
<div class="paragraph">
<p>With <code>on-error</code> function you can watch the error termination of an observable
sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sub</span> <span class="tok-p">(</span><span class="tok-nf">rx/on-end</span> <span class="tok-nv">sub</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="backpressure-aware-consimption"><a class="link" href="#backpressure-aware-consimption">Backpressure-aware consimption</a></h3>
<div class="paragraph">
<p>The streams created using the <code>generate</code> function, are backpressure-aware
streams and can be consumed in backpressure-aware way. For this you need to pass
object that implements the <code>ISubscriber</code> protocol. Let see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span>
  <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
       <span class="tok-p">(</span><span class="tok-nf">rx/to-flowable</span> <span class="tok-ss">:buffer</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe-with</span> <span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">reify</span> <span class="tok-nv">rx/ISubscriber</span>
                            <span class="tok-p">(</span><span class="tok-nf">-on-init</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">s</span><span class="tok-p">]</span>
                              <span class="tok-p">(</span><span class="tok-nf">s/request!</span> <span class="tok-nv">s</span> <span class="tok-mi">1</span><span class="tok-p">))</span>

                            <span class="tok-p">(</span><span class="tok-nf">-on-next</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">s</span> <span class="tok-nv">v</span><span class="tok-p">]</span>
                              <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-next:&quot;</span> <span class="tok-nv">v</span><span class="tok-p">)</span>
                              <span class="tok-p">(</span><span class="tok-nf">s/request!</span> <span class="tok-nv">s</span> <span class="tok-mi">1</span><span class="tok-p">))</span>

                            <span class="tok-p">(</span><span class="tok-nf">-on-error</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">e</span><span class="tok-p">]</span>
                              <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error&quot;</span><span class="tok-p">))</span>

                            <span class="tok-p">(</span><span class="tok-nf">-on-end</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
                              <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))))</span>
<span class="tok-c1">;; =&gt; on-next: 1</span>
<span class="tok-c1">;; =&gt; on-next: 2</span>
<span class="tok-c1">;; =&gt; on-next: 3</span>
<span class="tok-c1">;; =&gt; on-end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the same way as <code>subscribe</code> function, the <code>subscribe-with</code> returns
a cancellable subscription object.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transformations"><a class="link" href="#transformations">Transformations</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="filter"><a class="link" href="#filter">Filter</a></h3>
<div class="paragraph">
<p>The main advantage of using reactive streams is that you may treat them like
normal sequence, and in this case filter them with a predicate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/filter</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">&gt; </span><span class="tok-nv">%</span> <span class="tok-mi">3</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 4</span>
<span class="tok-c1">;; ==&gt; on-value: 5</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="map"><a class="link" href="#map">Map</a></h3>
<div class="paragraph">
<p>Also, you can apply a function over each value in the stream:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/map</span> <span class="tok-nv">inc</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="flat-map"><a class="link" href="#flat-map">Flat Map</a></h3>
<div class="paragraph">
<p>Convets an observable sequence that can contain other observable sequences in
an other observable sequences that emits just plain values.</p>
</div>
<div class="paragraph">
<p>The result is similar to concatenate all the underlying sequences.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/map</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nf">sfrom-coll</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-nv">%</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">%</span> <span class="tok-mi">2</span><span class="tok-p">))))</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/flat-map</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="skip"><a class="link" href="#skip">Skip</a></h3>
<div class="paragraph">
<p>Also, sometimes you just want to skip values from stream under different criteria.</p>
</div>
<div class="paragraph">
<p>You can skip the first N values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-mi">6</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/skip</span> <span class="tok-mi">4</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 5</span>
<span class="tok-c1">;; ==&gt; on-value: 6</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Skip while some condition evalutates to true:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/skip-while</span> <span class="tok-nv">odd?</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Or skip until an other observable yelds a value using <code>skip-until</code> (no example at
this moment).</p>
</div>
</div>
<div class="sect2">
<h3 id="take"><a class="link" href="#take">Take</a></h3>
<div class="paragraph">
<p>You also can limit the observale sequence to an specified number of elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/take</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Or an condition expression evaluates to true:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/take-while</span> <span class="tok-nv">odd?</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="slice"><a class="link" href="#slice">Slice</a></h3>
<div class="paragraph">
<p>This is a some kind of combination of <code>skip</code> and <code>take</code>, and returns an observable
sequence that represents a portion delimited by start and end of the source
observable sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/slice</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reduce"><a class="link" href="#reduce">Reduce</a></h3>
<div class="paragraph">
<p>Allows combine all results of an observable sequence using a combining function
also called (reducing function):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/reduce</span> <span class="tok-nb">+ </span><span class="tok-mi">0</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 10</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scan"><a class="link" href="#scan">Scan</a></h3>
<div class="paragraph">
<p>Allows combine all results of an observable sequence using a combining function
also called (reducing function). Returns a stream of each intermediate result
instead of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/scan</span> <span class="tok-nb">+ </span><span class="tok-mi">0</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-value: 6</span>
<span class="tok-c1">;; ==&gt; on-value: 10</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="buffer"><a class="link" href="#buffer">Buffer</a></h3>
<div class="paragraph">
<p>This transformer functions allow accomulate N specified values in a buffer and then
emits them as one value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
                 <span class="tok-p">(</span><span class="tok-nf">rx/buffer</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: [1 2]</span>
<span class="tok-c1">;; ==&gt; on-value: [3 4]</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="combinators"><a class="link" href="#combinators">Combinators</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="choice"><a class="link" href="#choice">Choice</a></h3>
<div class="paragraph">
<p>Perform an arbitrary choice between two or more observable sequences and return the
first value available from any provided observables.</p>
</div>
<div class="paragraph">
<p>This kind if combinator works very well with operations that can timeout:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/choice</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/timeout</span> <span class="tok-mi">1000</span> <span class="tok-ss">:timeout</span><span class="tok-p">)</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/timeout</span> <span class="tok-mi">900</span> <span class="tok-ss">:value</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: :value</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zip"><a class="link" href="#zip">Zip</a></h3>
<div class="paragraph">
<p>This combinator combines two observable sequences in one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/zip</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: [1 2]</span>
<span class="tok-c1">;; ==&gt; on-value: [2 3]</span>
<span class="tok-c1">;; ==&gt; on-value: [3 4]</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concat"><a class="link" href="#concat">Concat</a></h3>
<div class="paragraph">
<p>This cobinator concatenates two or more observable sequences.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/concat</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-value: 4</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="merge"><a class="link" href="#merge">Merge</a></h3>
<div class="paragraph">
<p>This combinator merges two or more observable sequences.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">rx/concat</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
              <span class="tok-p">(</span><span class="tok-nf">rx/from-coll</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; ==&gt; on-value: 1</span>
<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-value: 4</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
the order is not required to be the same always.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="subject"><a class="link" href="#subject">Subject</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is an abstraction that combines observable sequence with the observer. So
you can push values into it and transform and subscribe to it like any other
sequence.</p>
</div>
<div class="sect2">
<h3 id="creating-a-subject"><a class="link" href="#creating-a-subject">Creating a subject.</a></h3>
<div class="paragraph">
<p>You can create a subject instance using <code>subject</code> constructor function. There is an
example of using subject for the both operations: push values and subscribe to it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">subject</span> <span class="tok-p">(</span><span class="tok-nf">rx/subject</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">stream</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-nv">subject</span>
                <span class="tok-p">(</span><span class="tok-nf">rx/skip</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
                <span class="tok-p">(</span><span class="tok-nf">rx/map</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
                <span class="tok-p">(</span><span class="tok-nf">rx/take</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">stream</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/push!</span> <span class="tok-nv">subject</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">rx/push!</span> <span class="tok-nv">subject</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">rx/push!</span> <span class="tok-nv">subject</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">rx/push!</span> <span class="tok-nv">subject</span> <span class="tok-mi">2</span><span class="tok-p">)</span>

<span class="tok-c1">;; ==&gt; on-value: 3</span>
<span class="tok-c1">;; ==&gt; on-value: 2</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ending-a-subject"><a class="link" href="#ending-a-subject">Ending a subject</a></h3>
<div class="paragraph">
<p>You can end subject in any moment just executing <code>end!</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">subject</span> <span class="tok-p">(</span><span class="tok-nf">rx/subject</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/subscribe</span> <span class="tok-nv">subject</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-error:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;on-end&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">rx/end!</span> <span class="tok-nv">subject</span><span class="tok-p">)</span>
<span class="tok-c1">;; ==&gt; on-end</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="developers-guide"><a class="link" href="#developers-guide">Developers Guide</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="philosophy"><a class="link" href="#philosophy">Philosophy</a></h3>
<div class="paragraph">
<p>Five most important rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Beautiful is better than ugly.</p>
</li>
<li>
<p>Explicit is better than implicit.</p>
</li>
<li>
<p>Simple is better than complex.</p>
</li>
<li>
<p>Complex is better than complicated.</p>
</li>
<li>
<p>Readability counts.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All contributions to <em>beicon</em> should keep these important rules in mind.</p>
</div>
</div>
<div class="sect2">
<h3 id="contributing"><a class="link" href="#contributing">Contributing</a></h3>
<div class="paragraph">
<p>Unlike Clojure and other Clojure contributed libraries <em>beicon</em> does not have many
restrictions for contributions. Just open an issue or pull request.</p>
</div>
</div>
<div class="sect2">
<h3 id="source-code"><a class="link" href="#source-code">Source Code</a></h3>
<div class="paragraph">
<p><em>beicon</em> is open source and can be found on
<a href="https://github.com/funcool/beicon">github</a>.</p>
</div>
<div class="paragraph">
<p>You can clone the public repository with this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">git clone https://github.com/funcool/beicon</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="run-tests"><a class="link" href="#run-tests">Run tests</a></h3>
<div class="paragraph">
<p>For running tests just execute this:</p>
</div>
<div class="listingblock">
<div class="title">ClojureScript</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="shell">./scrpts/build
node ./out/tests.js</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Clojure</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="shell">lein test</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="license"><a class="link" href="#license">License</a></h3>
<div class="paragraph">
<p><em>beicon</em> is licensed under BSD (2-Clause) license:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Copyright (c) 2015-2016 Andrey Antukh &lt;niwi@niwi.nz&gt;

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-02-13 18:37:36 CET
</div>
</div>
</body>
</html>