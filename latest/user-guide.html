<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>User Guide</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">funcool/beicon</span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="user-guide.html"><div class="inner"><span>User Guide</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="beicon.v2.html"><div class="inner"><span>beicon.v2</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#user-guide" id="user-guide"></a>User Guide</h1>
<h2><a href="#introduction" id="introduction"></a>Introduction</h2>
<p><em>beicon</em> is a small and concise library that provides reactive streams API for ClojureScript.</p>
<h3><a href="#install" id="install"></a>Install</h3>
<p>The simplest way to use <em>beicon</em> in a Clojure project, is by including it the following dependency:</p>
<pre><code class="language-clojure">funcool/beicon2
{:git/tag "v2.1"
 :git/sha "e7b3ad9"
 :git/url "https://github.com/funcool/beicon.git"}
</code></pre>
<h2><a href="#creating-streams" id="creating-streams"></a>Creating Streams</h2>
<p>This section will give you the available methods for create observable streams.</p>
<h3><a href="#from-a-collection" id="from-a-collection"></a>From a collection</h3>
<p>The most basic way to create a stream is to just take a collection and convert it into an observable sequence:</p>
<pre><code class="language-clojure">(require '[beicon.v2 :as rx])

(def stream (rx/from [1 2 3]))

(rx/sub! stream #(println "v:" %))
;; ==&gt; v: 1
;; ==&gt; v: 2
;; ==&gt; v: 3
</code></pre>
<h3><a href="#from-range" id="from-range"></a>From range</h3>
<p>An other way to create an observable stream is using the <code>range</code> constructor, which is pretty analogous to the Clojures one:</p>
<pre><code class="language-clojure">(def stream (rx/range 3))

(rx/sub! stream #(println "v:" %))
;; ==&gt; v: 0
;; ==&gt; v: 1
;; ==&gt; v: 2
</code></pre>
<h3><a href="#from-atom" id="from-atom"></a>From Atom</h3>
<p>Atoms in Clojure are watchable, so you can listen for their changes. This method converts that changes into an infinite observable sequence of atom changes:</p>
<pre><code class="language-clojure">(def a (atom 1))

(def stream (rx/from-atom a))

(rx/sub! stream #(println "v:" %))
(swap! a inc)
;; ==&gt; v: 2
</code></pre>
<h3><a href="#from-values" id="from-values"></a>From values.</h3>
<p>There is a way to create an observable sequence from multiple values, using the <code>of</code> constructor:</p>
<pre><code class="language-clojure">(def stream (rx/of 1 2 3))

(rx/sub! stream #(println "v:" %))
;; ==&gt; v: 1
;; ==&gt; v: 2
;; ==&gt; v: 3
</code></pre>
<h3><a href="#empty" id="empty"></a>Empty</h3>
<p>Some times you also want just a terminated stream:</p>
<pre><code class="language-clojure">(def stream (rx/empty))
</code></pre>
<p>This stream does not yield any value and just terminates.</p>
<h3><a href="#with-timeout" id="with-timeout"></a>With timeout</h3>
<p>This allows to create an observable sequence of one unique value, that will be emitted after a specified amount of time:</p>
<pre><code class="language-clojure">(def stream (rx/timeout 1000 10))

(rx/sub! stream #(println "v:" %))
;; After 1 sec...
;; ==&gt; v: 10
</code></pre>
<h3><a href="#from-factory" id="from-factory"></a>From factory</h3>
<p>This is the most advanced and flexible way to create an observable sequence. It allows to have control about termination and errors, and is intended to be used for building other kinds of constructors.</p>
<pre><code class="language-clojure">(def stream
  (rx/create (fn [subs]
               (rx/push! subs 1)          ;; next with `1` as value
               (rx/push! subs 2)          ;; next with `2` as value
               (rx/end! subs)             ;; end the stream
               (fn []
                 ;; function called on unsubscription
                 ))))

(rx/sub! stream #(println "v:" %))
;; ==&gt; v: 1
;; ==&gt; v: 2
</code></pre>
<h2><a href="#consuming-streams" id="consuming-streams"></a>Consuming streams</h2>
<h3><a href="#the-stream-states" id="the-stream-states"></a>The stream states</h3>
<p>The observable sequence can be in three different kind of states: <em>alive</em>, <em>“errored”</em> or <em>ended</em>. If an error is emitted the stream can be considered ended with an error.  So <em>error</em> or <em>end</em> states are considered termination states.</p>
<p>And for convenience you can subscribe to any of that states of an observable sequence.</p>
<h3><a href="#general-purpose" id="general-purpose"></a>General purpose</h3>
<p>A general purpose subscription is one that allows you to create one subscription, that watches all the different possible states of an observable sequence:</p>
<pre><code class="language-clojure">(def sub (rx/sub! stream
                  #(println "on-value:" %)
                  #(println "on-error:" %)
                  #(println "on-end:")))
</code></pre>
<p>The return value of the <code>subscribe</code> function is a subscription object, that identifies the current subscription. It can be cancelled by executing <code>(rx/dispose! sub)</code>.</p>
<p>There is also the <code>subs!</code> function usefull for <code>-&gt;&gt;</code> ready call convention (expects receive the <code>observable</code> on the last argument position instead of the first position).</p>
<h2><a href="#transformations" id="transformations"></a>Transformations</h2>
<p>There are two call conventions here:</p>
<ul>
<li>The familiar fluent API, which just works like any clojure sequence transformations functions (<code>map</code>, <code>filter</code>, …)</li>
<li>The RxJS composition API, using <code>rx/pipe</code> and <code>rx/comp</code>.</li>
</ul>
<p>Let see the <code>filter</code> example to understand the differences.</p>
<h3><a href="#filter-map" id="filter-map"></a>Filter &amp; Map</h3>
<p>The main advantage of using reactive streams is that you may treat them like normal sequences, and in this case apply a function and then filter them with a predicate. Let’s use the fluent API:</p>
<pre><code class="language-clojure">(def stream
  (-&gt;&gt; (rx/from [1 2 3 4 5])
       (rx/map inc)
       (rx/filter #(&gt; % 3))))

(rx/sub! stream
         #(println "on-next:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-next: 4
;; ==&gt; on-next: 5
;; ==&gt; on-next: 6
;; ==&gt; on-end
</code></pre>
<p>The same can be expressed using the composition API:</p>
<pre><code class="language-clojure">
(def stream
  (-&gt;&gt; (rx/from [1 2 3 4 5])
       (rx/pipe (rx/map* inc))
       (rx/pipe (rx/filter* #(&gt; % 3)))
       (rx/subs! stream
                 #(println "on-next:" %)
                 #(println "on-error:" %)
                 #(println "on-end"))))
</code></pre>
<p>We also use the <code>subs!</code> helper for subscribe to the resulting observable in a single expression with <code>-&gt;&gt;</code>.</p>
<p>And finally, you can compose the transformation and later use it in the same way as transducers:</p>
<pre><code class="language-clojure">(def stream
  (-&gt;&gt; (rx/from [1 2 3 4 5])
       (rx/pipe (rx/comp (rx/map* inc)
                         (rx/filter* #(&gt; % 3))))
       (rx/subs! stream
                 #(println "on-next:" %)
                 #(println "on-error:" %)
                 #(println "on-end"))))
</code></pre>
<p>All functions that ends with the <code>*</code> (ASTERISK) means they are operator only and can not be used on fluent composition.</p>
<h3><a href="#merge-map" id="merge-map"></a>Merge Map</h3>
<p>Converts an observable sequence, that can contain other observable sequences, into a new observable sequence, that emits just plain values.</p>
<p>The result is similar to concatenating all the underlying sequences.</p>
<pre><code class="language-clojure">(def stream (-&gt;&gt; (rx/from [1 2])
                 (rx/merge-map #(rx/from (range % (+ % 2))))))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 1
;; ==&gt; on-value: 2
;; ==&gt; on-value: 2
;; ==&gt; on-value: 3
;; ==&gt; on-end
</code></pre>
<p>Aliases: <code>fmap</code>, <code>flat-map</code>.</p>
<h3><a href="#skip" id="skip"></a>Skip</h3>
<p>Also, sometimes you just want to skip values from stream by different criteria.</p>
<p>You can skip the first N values:</p>
<pre><code class="language-clojure">(def stream (-&gt;&gt; (rx/from [1 2 3 4 5 6])
                 (rx/skip 4)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 5
;; ==&gt; on-value: 6
;; ==&gt; on-end
</code></pre>
<p>Skip while some predicate evaluates to <code>true</code>:</p>
<pre><code class="language-clojure">(def stream (-&gt;&gt; (rx/from [1 1 1 1 2 3])
                 (rx/skip-while odd?)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 2
;; ==&gt; on-value: 3
;; ==&gt; on-end
</code></pre>
<p>Or skip until another observable yields a value with <code>skip-until</code> (no example at this moment).</p>
<h3><a href="#take" id="take"></a>Take</h3>
<p>You can also limit the observable sequence to an specified number of elements:</p>
<pre><code class="language-clojure">(def stream (-&gt;&gt; (rx/from [1 1 1 1 2 3])
                 (rx/take 2)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 1
;; ==&gt; on-value: 1
;; ==&gt; on-end
</code></pre>
<p>Or a predicate evaluates to <code>true</code>:</p>
<pre><code class="language-clojure">(def stream (-&gt;&gt; (rx/from [1 1 1 1 2 3])
                 (rx/take-while odd?)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 1
;; ==&gt; on-value: 1
;; ==&gt; on-value: 1
;; ==&gt; on-value: 1
;; ==&gt; on-end
</code></pre>
<h3><a href="#reduce" id="reduce"></a>Reduce</h3>
<p>Allows combining all results of an observable sequence using a combining function (also called <em>reducing</em> function):</p>
<pre><code class="language-clojure">(def stream (-&gt;&gt; (rx/from [1 2 3 4])
                 (rx/reduce + 0)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 10
;; ==&gt; on-end
</code></pre>
<h3><a href="#scan" id="scan"></a>Scan</h3>
<p>Like <code>reduce</code> (see above), but returns a stream of each intermediate result instead (similar to <code>reductions</code> in Clojure):</p>
<pre><code class="language-clojure">(def stream (-&gt;&gt; (rx/from [1 2 3 4])
                 (rx/scan + 0)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 1
;; ==&gt; on-value: 3
;; ==&gt; on-value: 6
;; ==&gt; on-value: 10
;; ==&gt; on-end
</code></pre>
<h3><a href="#buffer" id="buffer"></a>Buffer</h3>
<p>This transformer function allows to accumulate N values in a buffer and then emits them as one value (similar to <code>partition</code> in Clojure)</p>
<pre><code class="language-clojure">(def stream (-&gt;&gt; (rx/from [1 2 3 4])
                 (rx/buffer 2)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: [1 2]
;; ==&gt; on-value: [3 4]
;; ==&gt; on-end
</code></pre>
<h2><a href="#combinators" id="combinators"></a>Combinators</h2>
<h3><a href="#zip" id="zip"></a>Zip</h3>
<p>This combinator combines two observable sequences in one.</p>
<pre><code class="language-clojure">(def stream (rx/zip
              (rx/from [1 2 3])
              (rx/from [2 3 4])))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: [1 2]
;; ==&gt; on-value: [2 3]
;; ==&gt; on-value: [3 4]
;; ==&gt; on-end
</code></pre>
<h3><a href="#concat" id="concat"></a>Concat</h3>
<p>This combinator concatenates two or more observable sequences <em>in order</em>.</p>
<pre><code class="language-clojure">(def stream (rx/concat
              (rx/from [1 2])
              (rx/from [3 4])))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 1
;; ==&gt; on-value: 2
;; ==&gt; on-value: 3
;; ==&gt; on-value: 4
;; ==&gt; on-end
</code></pre>
<p>It ignores nil values from arguments</p>
<h3><a href="#merge" id="merge"></a>Merge</h3>
<p>This combinator merges two or more observable sequences <em>at random</em> (see <code>concat</code> for ordered).</p>
<pre><code class="language-clojure">(def stream (rx/merge
              (rx/from [1 2])
              (rx/from [3 4])))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 1
;; ==&gt; on-value: 3
;; ==&gt; on-value: 2
;; ==&gt; on-value: 4
;; ==&gt; on-end
</code></pre>
<p>It ignores nil values from arguments</p>
<h2><a href="#subject" id="subject"></a>Subject</h2>
<p>This is an abstraction that combines observable sequence with the observer. So you can push values into it and transform and subscribe to it like any other sequence.</p>
<h3><a href="#creating-a-subject" id="creating-a-subject"></a>Creating a subject.</h3>
<p>You can create a subject instance using the <code>subject</code> constructor function.</p>
<p>This is an example of using <code>subject</code> for two things: push values and subscribe to it.</p>
<pre><code class="language-clojure">(def subject (rx/subject))
(def stream (-&gt;&gt; subject
                 (rx/skip 1)
                 (rx/map inc)
                 (rx/take 2)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

(rx/push! subject 1)
(rx/push! subject 2)
(rx/push! subject 1)
(rx/push! subject 2)

;; ==&gt; on-value: 3
;; ==&gt; on-value: 2
;; ==&gt; on-end
</code></pre>
<h3><a href="#ending-a-subject" id="ending-a-subject"></a>Ending a subject</h3>
<p>You can end a subject at any moment just by executing the <code>end!</code> function:</p>
<pre><code class="language-clojure">(def subject (rx/subject))

(rx/sub! subject
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

(rx/end! subject)
;; ==&gt; on-end
</code></pre>
<h2><a href="#developers-guide" id="developers-guide"></a>Developers Guide</h2>
<h3><a href="#source-code" id="source-code"></a>Source Code</h3>
<p><em>beicon</em> is open source and can be found on link:<a href="https://github.com/funcool/beicon">https://github.com/funcool/beicon</a><a href="github">github</a>.</p>
<p>You can clone the public repository with this command:</p>
<pre><code>git clone https://github.com/funcool/beicon
</code></pre>
<h3><a href="#run-tests" id="run-tests"></a>Run tests</h3>
<p>For running tests just execute this:</p>
<pre><code class="language-bash">yarn run test:watch
</code></pre>
<h3><a href="#license" id="license"></a>License</h3>
<p><em>beicon</em> is licensed under BSD (2-Clause) license:</p>
<pre><code>Copyright (c) 2015-2024 Andrey Antukh &lt;niwi@niwi.nz&gt;

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</code></pre>
</div></div></div></body></html>