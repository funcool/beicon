<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>User Guide</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">funcool/beicon</span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="user-guide.html"><div class="inner"><span>User Guide</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="beicon.core.html"><div class="inner"><span>beicon.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#user-guide" name="user-guide"></a>User Guide</h1>
<h2><a href="#introduction" name="introduction"></a>Introduction</h2>
<p><em>beicon</em> is a small and concise library that provides reactive streams API for ClojureScript.</p>
<h3><a href="#install" name="install"></a>Install</h3>
<p>The simplest way to use <em>beicon</em> in a Clojure project, is by including it in the dependency vector on your <em><em>project.clj</em></em> file:</p>
<pre><code class="clojure">funcool/beicon {:mvn/version "RELEASE"}
</code></pre>
<h2><a href="#creating-streams" name="creating-streams"></a>Creating Streams</h2>
<p>This section will give you the available methods for create observable streams.</p>
<h3><a href="#from-a-collection" name="from-a-collection"></a>From a collection</h3>
<p>The most basic way to create a stream is to just take a collection and convert it into an observable sequence:</p>
<pre><code class="clojure">(require '[beicon.core :as rx])

(def stream (rx/from [1 2 3]))

(rx/sub! stream #(println "v:" %))
;; ==&gt; v: 1
;; ==&gt; v: 2
;; ==&gt; v: 3
</code></pre>
<h3><a href="#from-range" name="from-range"></a>From range</h3>
<p>An other way to create an observable stream is using the <code>range</code> constructor, which is pretty analogous to the Clojures one:</p>
<pre><code class="clojure">(def stream (rx/range 3))

(rx/sub! stream #(println "v:" %))
;; ==&gt; v: 0
;; ==&gt; v: 1
;; ==&gt; v: 2
</code></pre>
<h3><a href="#from-atom" name="from-atom"></a>From Atom</h3>
<p>Atoms in Clojure are watchable, so you can listen for their changes. This method converts that changes into an infinite observable sequence of atom changes:</p>
<pre><code class="clojure">(def a (atom 1))

(def stream (rx/from-atom a))

(rx/sub! stream #(println "v:" %))
(swap! a inc)
;; ==&gt; v: 2
</code></pre>
<h3><a href="#from-values-" name="from-values-"></a>From values.</h3>
<p>There is a way to create an observable sequence from multiple values, using the <code>of</code> constructor:</p>
<pre><code class="clojure">(def stream (rx/of 1 2 3))

(rx/sub! stream #(println "v:" %))
;; ==&gt; v: 1
;; ==&gt; v: 2
;; ==&gt; v: 3
</code></pre>
<h3><a href="#empty" name="empty"></a>Empty</h3>
<p>Some times you also want just a terminated stream:</p>
<pre><code class="clojure">(def stream (rx/empty))
</code></pre>
<p>This stream does not yield any value and just terminates.</p>
<h3><a href="#with-timeout" name="with-timeout"></a>With timeout</h3>
<p>This allows to create an observable sequence of one unique value, that will be emitted after a specified amount of time:</p>
<pre><code class="clojure">(def stream (rx/timeout 1000 10))

(rx/sub! stream #(println "v:" %))
;; After 1 sec...
;; ==&gt; v: 10
</code></pre>
<h3><a href="#from-factory" name="from-factory"></a>From factory</h3>
<p>This is the most advanced and flexible way to create an observable sequence. It allows to have control about termination and errors, and is intended to be used for building other kinds of constructors.</p>
<pre><code class="clojure">(def stream
  (rx/create (fn [subs]
               (rx/push! subs 1)          ;; next with `1` as value
               (rx/push! subs 2)          ;; next with `2` as value
               (rx/end! subs)             ;; end the stream
               (fn []
                 ;; function called on unsubscription
                 ))))

(rx/sub! stream #(println "v:" %))
;; ==&gt; v: 1
;; ==&gt; v: 2
</code></pre>
<h2><a href="#consuming-streams" name="consuming-streams"></a>Consuming streams</h2>
<h3><a href="#the-stream-states" name="the-stream-states"></a>The stream states</h3>
<p>The observable sequence can be in three different kind of states: <em>alive</em>, <em>“errored”</em> or <em>ended</em>. If an error is emitted the stream can be considered ended with an error. So <em>error</em> or <em>end</em> states are considered termination states.</p>
<p>And for convenience you can subscribe to any of that states of an observable sequence.</p>
<h3><a href="#general-purpose" name="general-purpose"></a>General purpose</h3>
<p>A general purpose subscription is one that allows you to create one subscription, that watches all the different possible states of an observable sequence:</p>
<pre><code class="clojure">(def sub (rx/sub! stream
                  #(println "on-value:" %)
                  #(println "on-error:" %)
                  #(println "on-end:")))
</code></pre>
<p>The return value of the <code>subscribe</code> function is a subscription object, that identifies the current subscription. It can be cancelled by executing <code>(rx/dispose! sub)</code>.</p>
<h2><a href="#transformations" name="transformations"></a>Transformations</h2>
<h3><a href="#filter" name="filter"></a>Filter</h3>
<p>The main advantage of using reactive streams is that you may treat them like normal sequences, and in this case filter them with a predicate:</p>
<pre><code class="clojure">(def stream (-&gt;&gt; (rx/from [1 2 3 4 5])
                 (rx/filter #(&gt; % 3))))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 4
;; ==&gt; on-value: 5
;; ==&gt; on-end
</code></pre>
<h3><a href="#map" name="map"></a>Map</h3>
<p>Also, you can apply a function over each value in the stream:</p>
<pre><code class="clojure">(def stream (-&gt;&gt; (rx/from [1 2])
                 (rx/map inc)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 2
;; ==&gt; on-value: 3
;; ==&gt; on-end
</code></pre>
<h3><a href="#merge-map" name="merge-map"></a>Merge Map</h3>
<p>Converts an observable sequence, that can contain other observable sequences, into a new observable sequence, that emits just plain values.</p>
<p>The result is similar to concatenating all the underlying sequences.</p>
<pre><code class="clojure">(def stream (-&gt;&gt; (rx/from [1 2])
                 (rx/merge-map #(rx/from (range % (+ % 2))))))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 1
;; ==&gt; on-value: 2
;; ==&gt; on-value: 2
;; ==&gt; on-value: 3
;; ==&gt; on-end
</code></pre>
<p>Aliases: <code>fmap</code>, <code>flat-map</code>.</p>
<h3><a href="#skip" name="skip"></a>Skip</h3>
<p>Also, sometimes you just want to skip values from stream by different criteria.</p>
<p>You can skip the first N values:</p>
<pre><code class="clojure">(def stream (-&gt;&gt; (rx/from [1 2 3 4 5 6])
                 (rx/skip 4)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 5
;; ==&gt; on-value: 6
;; ==&gt; on-end
</code></pre>
<p>Skip while some predicate evaluates to <code>true</code>:</p>
<pre><code class="clojure">(def stream (-&gt;&gt; (rx/from [1 1 1 1 2 3])
                 (rx/skip-while odd?)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 2
;; ==&gt; on-value: 3
;; ==&gt; on-end
</code></pre>
<p>Or skip until another observable yields a value with <code>skip-until</code> (no example at this moment).</p>
<h3><a href="#take" name="take"></a>Take</h3>
<p>You can also limit the observable sequence to an specified number of elements:</p>
<pre><code class="clojure">(def stream (-&gt;&gt; (rx/from [1 1 1 1 2 3])
                 (rx/take 2)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 1
;; ==&gt; on-value: 1
;; ==&gt; on-end
</code></pre>
<p>Or a predicate evaluates to <code>true</code>:</p>
<pre><code class="clojure">(def stream (-&gt;&gt; (rx/from [1 1 1 1 2 3])
                 (rx/take-while odd?)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 1
;; ==&gt; on-value: 1
;; ==&gt; on-value: 1
;; ==&gt; on-value: 1
;; ==&gt; on-end
</code></pre>
<h3><a href="#slice" name="slice"></a>Slice</h3>
<p>This is a combination of <code>skip</code> and <code>take</code>, and returns an observable sequence, that represents the portion between start and end of the source observable sequence.</p>
<pre><code class="clojure">(def stream (-&gt;&gt; (rx/from [1 2 3 4])
                 (rx/slice 1 3)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 2
;; ==&gt; on-value: 3
;; ==&gt; on-end
</code></pre>
<h3><a href="#reduce" name="reduce"></a>Reduce</h3>
<p>Allows combining all results of an observable sequence using a combining function (also called <em>reducing</em> function):</p>
<pre><code class="clojure">(def stream (-&gt;&gt; (rx/from [1 2 3 4])
                 (rx/reduce + 0)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 10
;; ==&gt; on-end
</code></pre>
<h3><a href="#scan" name="scan"></a>Scan</h3>
<p>Like <code>reduce</code> (see above), but returns a stream of each intermediate result instead (similar to <code>reductions</code> in Clojure):</p>
<pre><code class="clojure">(def stream (-&gt;&gt; (rx/from [1 2 3 4])
                 (rx/scan + 0)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 1
;; ==&gt; on-value: 3
;; ==&gt; on-value: 6
;; ==&gt; on-value: 10
;; ==&gt; on-end
</code></pre>
<h3><a href="#buffer" name="buffer"></a>Buffer</h3>
<p>This transformer function allows to accumulate N values in a buffer and then emits them as one value (similar to <code>partition</code> in Clojure)</p>
<pre><code class="clojure">(def stream (-&gt;&gt; (rx/from [1 2 3 4])
                 (rx/buffer 2)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: [1 2]
;; ==&gt; on-value: [3 4]
;; ==&gt; on-end
</code></pre>
<h2><a href="#combinators" name="combinators"></a>Combinators</h2>
<h3><a href="#choice" name="choice"></a>Choice</h3>
<p>Performs an arbitrary choice between two or more observable sequences and returns the first value available from any provided observables.</p>
<p>This kind of combinator works very well with operations that can timeout:</p>
<pre><code class="clojure">(def stream (rx/choice
              (rx/timeout 1000 :timeout)
              (rx/timeout 900 :value)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: :value
;; ==&gt; on-end
</code></pre>
<h3><a href="#zip" name="zip"></a>Zip</h3>
<p>This combinator combines two observable sequences in one.</p>
<pre><code class="clojure">(def stream (rx/zip
              (rx/from [1 2 3])
              (rx/from [2 3 4])))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: [1 2]
;; ==&gt; on-value: [2 3]
;; ==&gt; on-value: [3 4]
;; ==&gt; on-end
</code></pre>
<h3><a href="#concat" name="concat"></a>Concat</h3>
<p>This combinator concatenates two or more observable sequences <em>in order</em>.</p>
<pre><code class="clojure">(def stream (rx/concat
              (rx/from [1 2])
              (rx/from [3 4])))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 1
;; ==&gt; on-value: 2
;; ==&gt; on-value: 3
;; ==&gt; on-value: 4
;; ==&gt; on-end
</code></pre>
<h3><a href="#merge" name="merge"></a>Merge</h3>
<p>This combinator merges two or more observable sequences <em>at random</em> (see <code>concat</code> for ordered).</p>
<pre><code class="clojure">(def stream (rx/merge
              (rx/from [1 2])
              (rx/from [3 4])))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

;; ==&gt; on-value: 1
;; ==&gt; on-value: 3
;; ==&gt; on-value: 2
;; ==&gt; on-value: 4
;; ==&gt; on-end
</code></pre>
<h2><a href="#subject" name="subject"></a>Subject</h2>
<p>This is an abstraction that combines observable sequence with the observer. So you can push values into it and transform and subscribe to it like any other sequence.</p>
<h3><a href="#creating-a-subject-" name="creating-a-subject-"></a>Creating a subject.</h3>
<p>You can create a subject instance using the <code>subject</code> constructor function.</p>
<p>This is an example of using <code>subject</code> for two things: push values and subscribe to it.</p>
<pre><code class="clojure">(def subject (rx/subject))
(def stream (-&gt;&gt; subject
                 (rx/skip 1)
                 (rx/map inc)
                 (rx/take 2)))

(rx/sub! stream
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

(rx/push! subject 1)
(rx/push! subject 2)
(rx/push! subject 1)
(rx/push! subject 2)

;; ==&gt; on-value: 3
;; ==&gt; on-value: 2
;; ==&gt; on-end
</code></pre>
<h3><a href="#ending-a-subject" name="ending-a-subject"></a>Ending a subject</h3>
<p>You can end a subject at any moment just by executing the <code>end!</code> function:</p>
<pre><code class="clojure">(def subject (rx/subject))

(rx/sub! subject
         #(println "on-value:" %)
         #(println "on-error:" %)
         #(println "on-end"))

(rx/end! subject)
;; ==&gt; on-end
</code></pre>
<h2><a href="#developers-guide" name="developers-guide"></a>Developers Guide</h2>
<h3><a href="#philosophy" name="philosophy"></a>Philosophy</h3>
<p>Five most important rules:</p>
<ul>
  <li>Beautiful is better than ugly.</li>
  <li>Explicit is better than implicit.</li>
  <li>Simple is better than complex.</li>
  <li>Complex is better than complicated.</li>
  <li>Readability counts.</li>
</ul>
<p>All contributions to <em>beicon</em> should keep these important rules in mind.</p>
<h3><a href="#contributing" name="contributing"></a>Contributing</h3>
<p>Unlike Clojure and other Clojure contributed libraries <em>beicon</em> does not have many restrictions for contributions. Just open an issue or pull request.</p>
<h3><a href="#source-code" name="source-code"></a>Source Code</h3>
<p><em>beicon</em> is open source and can be found on link:<a href="https://github.com/funcool/beicon[github]">https://github.com/funcool/beicon[github]</a>.</p>
<p>You can clone the public repository with this command:</p>
<pre><code>git clone https://github.com/funcool/beicon
</code></pre>
<h3><a href="#run-tests" name="run-tests"></a>Run tests</h3>
<p>For running tests just execute this:</p>
<pre><code class="bash">clojure -M:dev tools build:tests
node ./out/tests.js
</code></pre>
<h3><a href="#license" name="license"></a>License</h3>
<p><em>beicon</em> is licensed under BSD (2-Clause) license:</p>
<pre><code>Copyright (c) 2015-2019 Andrey Antukh &lt;niwi@niwi.nz&gt;

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</code></pre></div></div></div></body></html>